# chapter 7 프로세스 생성과 실행

## 1. 프로세스 생성

  프로세스는 프로그램 안에서 다른 프로그램을 실행해 생성하기도 한다.

  ### system() 함수로 프로그램 실행하기
    
    system() 함수는 프로그램 안에서 새로운 프로그램을 실행시키는 가장 간단한 방법이지만 명령을 실행하기 위해 셸까지 동작시키므로 비효율적이다.

    system(): 프로그램 실행
    --------------------------------------
    #include <stdlib.h>

    int system(const char *command);

    * command: 실행할 명령이나 실행 파일명
    --------------------------------------
    기존 명령이나 실행 파일명을 인자로 받아 셸에 전달한다.
    셸은 내부적으로 새 프로세스를 생성해 인자로 받은 명령을 실행하고, 해당 명령의 실행이 끝날 때까지 기다렸다가 종료 상태를 리턴함.

  ### 프로세스 생성
  
    fork 함수는 부모 프로세스를 거의 그대로 복제해 새로운 프로세스를 생성한다.
    fork() 함수가 생성한 새로운 프로세스를 자식 프로세스라고 한다.
    fork() 함수를 호출한 프로세스는 부모 프로세스가 된다. 
    fork() 함수가 리턴하면 부모 프로세스와 자식 프로세스가 동시에 동작하는데, 어느 프로세스가 먼저 실행될지는 알 수 없다.
    처리 순서는 시스템의 스케줄링에 따라 달라진다.

  ### fork 함수의 특징

    1. fork 함수를 호출
    2. 새로운 프로세스를 생성한다.(자식 프로세스)
    3. fork() 함수로 생성한 자식 프로세스의 메모리 공간은 부모 프로세스의 메모리 공간을 그대로 복사해서 만든다.
    4. fork() 함수는 부모 프로세스에는 자식 프로세스의 PID를 리턴하고 자식 프로세스에는 0을 리턴한다.

    자식 프로세스는 부모 프로세스의 메모리를 복사할 뿐만 아니라 다양한 속성을 상속받는다.

    - 자식 프로세스가 상속받는 대표적인 속성은
    ---------------------------------------------------------------------------------
    실제 사용자 ID(RUID), 유효 사용자 ID(EUID), 실제 그룹 ID(RGID), 유효 그룹 ID(EGID)
    환경 변수
    열린 파일 기술자
    시그널 처리 설정
    setuid, setgid 설정
    현재 작업 디렉토리
    unmask 설정값
    사용 가능한 자원 제한
    ---------------------------------------------------------------------------------

    - 자식 프로세스는 부모 프로세스의 속성을 대부분 상속 받지만 부모 프로세스와 다른 점
    ---------------------------------------------------------------------------------
    자식 프로세스는 새로 할당한 프로세스 ID를 갖는다.
    자식 프로세스는 부모 프로세스의 PPID와 다른 자신만의 PPID를 갖는다. 즉, 자식 프로세스를 호출한 부모 프로세스가 자식 프로세스의 PPID로 설정된다.
    자식 프로세스는 부모 프로세스가 연 파일 기술자에 대한 복사본을 갖고 있다. 따라서 부모 프로세스와 자식 프로세스가 같은 파일의 오프셋을 공유하고 있는 상태가 되므로 읽거나 쓸 때 주의해야 한다.
    자식 프로세스는 부모 프로세스가 설정한 프로세스 잠금, 파일 잠금, 기타 메모리 잠금 등은 상속하지 않는다.
    처리되지 않은 시그널은 자식 프로세스로 상속되지 않는다.
    자식 프로세스의 tms 구조체 값은 0으로 초기화된다. 즉, 프로세스 실행 시간을 측정하는 기준 값이 새로 설정된다.
    ---------------------------------------------------------------------------------
    
    fork(): 프로세스 생성
    --------------------------------------------------
    #include <sys/types.h>
    #include <unistd.h>

    pid_t fork(void);
    --------------------------------------------------
    인자를 받지 않는다. 수행에 성공하면 부모 프로세스에는 자식 프로세스의 PID를, 자식 프로세스에는 0을 리턴한다.

    vfork(): 프로세스 생성
    --------------------------------------------------
    #include <unistd.h>

    pid_t vfork(void);
    --------------------------------------------------
    fork() 함수처럼 새로운 프로세스를 생성하지만 부모 프로세스의 메모리 공간을 모두 복사하지는 않는다.

## 2. 프로세스 종료

  프로세스가 종료되면 해당 프로세스가 어떻게 종료되었는지를 나타내는 종료 상태를 저장한다. </br>
  부모 프로세스는 저장된 종료 상태 정보를 사용해 자식 프로세스가 어떻게 종료되었는지 알 수 있다. </br>
  자식 프로세스는 부모 프로세스에 자신이 어떻게 종료되었는지 알리는 종료 상태값을 리턴할 수 있다. </br>

    exit(): 프로그램 종료
    --------------------------------------------------
    #include <stdlib.h>

    void exit(int status);

    * status: 종료 상태값
    --------------------------------------------------
    프로세스를 종료시키고 부모 프로세스에 종료 상태값을 전달한다.
    이때 atexit() 함수로 예약한 함수로 지정된 순서와 역순으로 모두 실행한다.
    만일 atexit() 함수로 예약한 함수가 수행 도중에 문제가 발생해 리턴하지 못하면 exit() 함수의 나머지 과정도 수행되지 않는다.
    exit() 함수는 프로세스가 사용 중이던 모든 표준 입출력 스트림에 데이터가 남아 있으면 이를 모두 기록하고 열려 있는 스트림을 모두 닫는다. 
    그 다음 tmpfile() 함수로 생성한 임시 파일을 모두 삭제하고 _exit() 함수를 호출한다. _exit() 함수는 시스템 호출인데 프로세스가 사용하던 모든 자원을 반납한다.
    이는 exit() 함수가 c표준 함수이기 때문에 시스템에 독립적인 기능만 수행하고 시스템과 관련된 기능은 시스템 호출에서 처리하도록 해야 하기 때문이다.

    atexit(): 프로그램 종료 시 수행할 작업 예약
    --------------------------------------------------
    #include <stdlib.h>

    int atexit(void (*function)(void));
    int on_exit(void (*function)(int , void *), void *arg);

    * function: 종료 시 수행할 작업을 지정한 함수명
    --------------------------------------------------
    atexit()와 on_exit() 함수는 프로세스가 종료할 때 수행할 기능을 예약한다.
    atexit() 함수는 인자로 함수의 포인터를 받고 on_exit() 함수는 함수의 포인터와 이 함수의 인자의 포인터를 받는다. 
    atexit() 함수에 인자로 지정하는 함수는 인자와 리턴값이 없는 함수다.

    _exit(): 프로그램 종료
    --------------------------------------------------
    #include <unistd.h>

    void _exit(int status);

    * status: 종료 상태값
    --------------------------------------------------
    _exit() 함수는 프로그램에서 직접 사용하지 않고 exit() 함수 내부에서 호출한다.
    _exit() 함수는 시스템 호출로 프로세스를 종료할 때 아래와 같은 과정을 거쳐 시스템 관련 자원을 정리함.
    모든 파일 기술자를 닫는다. -> 부모 프로세스에 종료 상태를 알린다. -> 자식 프로세스에 SIGHUP 시그널을 보낸다. -> 부모 프로세스에 SIGCHLD 시그널을 보낸다. -> 프로세스 간 통신에 사용한 자원을 반납한다.

  ## 3. exec() 함수군 활용

    exec 함수군을 사용해 명령이나 실행 파일을 실행할 수 있다. </br>
    exec 함수군은 인자로 받은 다른 프로그램을 자신을 호출한 프로세스의 메모리에 덮어쓴다. 따라서 프로세스가 수행 중이던 기존 프로그램은 중지되어 없어지고 새로 덮어쓴 프로그램이 실행된다.
    exec 함수군은 fork() 함수와 연결해 fork() 함수로 생성한 자식 프로세스가 새로운 프로그램을 실행하도록 할 때 유용함.

    --------------------------------------------------
    #include <unistd.h>

    int execl(const char *pathname, const char *arg, ... /* (char *) NULL */);
    int execlp(const char *file, const char *arg, ... /* (char *) NULL */);
    int execle(const char *pathname, const char *arg, ...
                          /*, (char *) NULL, char *const envp[] */);
    int execv(const char *pathname, char *const argv[]);
    int execvp(const char *file, char *const argv[]);
    int execvpe(const char *file, char *const argv[], char *const envp[]);
    --------------------------------------------------
    exec 함수군은 인자로 전달한 pathname이나 file에 설정한 명령이나 실행 파일을 실행한다.
    이때 arg나 envp로 시작하는 인자를 pathname이나 file에 지정한 파일의 main() 함수에 전달한다.
    각 함수별로 경로명까지 지정하거나 단순히 실행 파일명만 지정하는 등 차이가 있고 인자를 전달하는 형태에도 차이가 있다.
    execl(): pathname에 지정한 경로명의 파일을 실행하며 arg0~argn을 인자로 전달한다. 첫 인자인 arg0에는 실행 파일명을 지정한다. execl() 함수의 마지막 인자로는 인자의 끝을 의미하는 NULL 포인터((char *)0)를 지정해야 한다.
    pathname에 지정하는 경로명은 절대 경로나 상대 경로 모두 사용할 수 있다.
    execlp(): file에 지정한 파일을 실행하며 arg0~argn만 인자로 전달한다. 이 함수를 호출한 프로세스의 검색 경로(환경 변수 PATH에 정의된 경로)에서 파일을 찾는다. arg0~argn은 포인터로 지정한다.
    execlp() 함수의 마지막 인자는 NULL 포인터로 지정해야 한다.
    execle(): pathname에 지정한 경로명의 파일을 실행하며 arg0~argn과 envp를 인자로 전달한다.envp에는 새로운 환경 변수를 설정할 수 있다. arg0~argn을 포인터로 지정하므로 마지막 값은 NULL 포인터로 지정해야 한다.
    envp는 포인터 배열이다. 이 배열의 마지막에는 NULL 문자열을 저장해야 한다.
    execv(): pathname에 지정한 경로명에 있는 파일을 실행하며 argv를 인자로 전달한다. argv는 포인터 배열이다. 이 배열의 마지막에는 NULL 문자열을 저장해야 한다.
    execvp(): file에 지정한 파일을 실행하며 argv를 인자로 전달한다. argv는 포인터 배열이다. 이 배열의 마지막에는 NULL 문자열을 저장해야 한다.
    execvpe(): pathname에 지정한 경로명의 파일을 실행하며 argv, envp를 인자로 전달한다. argv와 envp는 포인터 배열이다. 이 배열의 마지막에는 NULL 문자열을 저장해야 한다.

  ## 4. 프로세스 동기화

    fork 함수로 자식 프로세스를 생성하면 부모 프로세스와 자식 프로세스는 순서에 관계없이 실행되고 먼저 실행을 마친 프로세스는 종료한다. 하지만, 부모 프로세스와 자식 프로세스 사이의 종료 절차가 제대로 진행되지 않을 때가 있다.
    이때 좀비 프로세스 같은 불안정 상태의 프로세스가 발생하는데 이를 방지하려면 부모 프로세스와 자식 프로세스를 동기화해야 한다.

    ### 좀비 프로세스
    정상적인 프로세스 종료 과정은 자식 프로세스가 종료를 위해 부모 프로세스에 종료 상태 정보를 보내고 이 정보를 받은 부모 프로세스는 프로세스 테이블에서 자식 프로세스를 삭제한다.
    그러나 자식 프로세스가 모든 자원을 반납했어도 부모 프로세스가 종료 상태 정보를 받지 않거나 자식 프로세스보다 먼저 종료하는 경우가 있다.

    실행을 종료한 후 자원을 반납한 자식 프로세스의 종료 상태 정보를 부모 프로세스가 받지 않는 경우에는 좀비 프로세스가 발생한다. 좀비 프로세스는 프로세스 테이블에만 존재한다.
    일반적인 방법으로는 제거할 수 없고 부모 프로세스가 wait() 함수를 호출해야 사라진다.

    ### 프로세스 동기화
    부모 프로세스와 자식 프로세스를 동기화하려면 부모 프로세스는 자식 프로세스가 종료될 때까지 기다려야 한다.

    wait(): 프로세스 동기화
    --------------------------------------------------
    #include <sys/types.h>
    #include <sys/wait.h>

    pid_t wait(int *wstatus);

    * wstatus: 상태 정보를 저장할 주소
    --------------------------------------------------
    자식 프로세스가 종료할 때까지 부모 프로세스를 기다리게 한다. 자식 프로세스의 종료 상태는 wstatus에 지정한 주소에 저장된다.
    wstatus에 NULL을 지정할 수도 있다.

    waitpid(): 특정 자식 프로세스와 동기화
    --------------------------------------------------
    #include <sys/types.h>
    #include <sys/wait.h>

    pid_t waitpid(pid_t pid, int *wstatus, int options);

    * pid: 종료를 기다리는 PID
    * status: 종료 상태값을 저장할 주소
    options: waitpid() 함수의 리턴 조건
    --------------------------------------------------
    wait() 함수는 자식 프로세스가 여러개일 경우 아무 자식 프로세스나 종료하면 리턴하지만 waitpid() 함수는 특정 PID의 자식 프로세스가 종료하기를 기다린다. 
    waitpid() 함수는 pid로 지정한 자식 프로세스가 종료하기를 기다리며, 자식 프로세스의 종료 상태값을 status에 저장하고 options의 조건에 따라 리턴한다.

    첫번째 인자인 pid에 지정할 수 있는 값과 의미
    -1보다 작은 경우: pid의 절대값과 같은 프로세스 그룹 ID에 속한 자식 프로세스 중 임의의 프로세스의 상태값을 요청한다.
    -1인 경우: wait() 함수처럼 임의의 자식 프로세스의 상태값을 요청한다.
    0인 경우: 함수를 호출한 프로세스와 같은 프로세스 그룹에 속한 임의의 프로세스 상태값을 요청한다.
    0보다 큰 경우: 지정한 pid에 해당하는 프로세스의 상태값을 요청한다. 

    세번째 인자인 options에 지정할 수 있는 값은 sys/wait.h에 정의되어 있으며, OR 연산으로 연결해 지정할 수 있다.
    WCONTINUED: 수행 중인 자식 프로세스의 상태값을 리턴한다.
    WNOHANG: pid로 지정한 자식 프로세스의 상태값을 즉시 리턴받을 수 없어도 이를 호출한 프로세스의 실행을 블로킹하지 않고 다른 작업을 수행하게 한다.
    WNOWAIT: 상태값을 리턴한 프로세스가 대기 상태로 머물 수 있도록 한다.
    WUNTRACED: 실행을 중단한 자식 프로세스의 상태값을 리턴한다. 실행이 중단되었으므로 더 이상 상태값을 리턴하지 않는다.

    waitid(): 특정 자식 프로세스와 동기화
    --------------------------------------------------
    #include <sys/types.h>
    #include <sys/wait.h>

    int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);

    * iptype: 종료를 기다리는 자식 프로세스 유형 정의
    * id: 식별 번호
    * infop: siginfo_t 구조체 포인터
    * options: waitid() 함수의 리턴 조건
    --------------------------------------------------
    POSIX 표준으로 리눅스에서 제공함. waitpid() 함수와 마찬가지로 특정 자식 프로세스가 종료하기를 기다리게 할 수 있다.
    waitpid() 함수가 기다리는 자식 프로세스의 PID만 인자로 지정하는 것과 달리 waitid() 함수는 좀 더 세부적으로 정의할 수 있다.

    idtype: 기다리는 자식 프로세스를 지정하고 다음 값 중 하나를 지정함.
    P_PID: pid가 id와 일치하는 자식 프로세스를 기다린다. 
    P_GID: gid가 id와 일치하는 자식 프로세스를 기다린다.
    P_ALL: 모든 자식 프로세스를 기다린다. 이 경우 id값은 무시함.

    id: pid나 gid 등 자식 프로세스를 구분할 수 있는 식별 번호를 지정
    
    infop: waitid() 함수가 성공하면 결과값을 채워서 돌려주는 siginfo_t 구조체이다. 이 구조체는 다음 값을 돌려준다.
    si_pid: 자식 프로세스의 PID
    si_uid: 자식 프로세스의 UID
    si_signo: 시그널로 항상 SIGCHLD로 설정
    si_status: 자식 프로세스의 종료 상태값
    si_code: 자식 프로세스가 종료된 이유 코드 저장
      CLD_EXITED: 자식 프로세스가 _exit() 함수를 호출해 종료
      CLD_KILLED: 자식 프로세스가 시그널을 받고 종료
      CLD_DUMPED: 자식 프로세스가 시그널을 받고 종료하고 코어 덤프 수행
      CLD_STOPPED: 자식 프로세스가 시그널을 받고 중단된 상태
      CLD_CONTINUE: SIGCONT 시그널을 받고 자식 프로세스가 계속 실행

    options: waitid() 함수의 리턴 조건은 다음 값을 OR로 연결할 수 있다.
    WEXITED: 자식 프로세스가 종료될 때까지 기다린다.
    WSTOPPED: 시그널을 받아 중단된 자식 프로세스를 기다린다.
    WCONTINUED: 시그널을 받아 다시 수행 중인 자식 프로세스를 기다린다.
    WNOHANG: waitpid()에서와 같다.
    WNOWAIT: 상태값을 리턴한 프로세스가 대기 상태로 머물 수 있도록 한다.
