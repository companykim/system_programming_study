# chapter 8 시그널

## 1. 시그널의 개념

프로세스에 뭔가 발생했음을 알리는 간단한 메시지를 비동기적으로 보내는 것. </br>  
무엇이 발생했는지를 표시하는 미리 정의된 상수를 사용함. 시그널을 받은 프로세스는 종류에 따라 적절한 처리 방법을 지정할 수 있다.
  
  ### 시그널의 발생
  
  시그널은 소프트웨어 인터럽트다. 비동기적으로 발생하며, 리눅스 운영체제가 프로세스에 전달함.

  0으로 나누기처럼 프로그램에서 예외적인 상황이 일어나는 경우 </br>
  프로세스가 kill() 함수와 같이 시그널을 보낼 수 있는 함수를 사용해 다른 프로세스에 시그널을 보내는 경우 </br>
  사용자가 ctrl + c 같은 인터럽트 키를 입력한 경우

  ### 시그널 처리 방법
  
  기본 동작 수행: 각 시그널에는 기본 동작이 지정되어 있다. 대부분 시그널의 기본 동작은 프로세스를 종료하는 것이다. </br>
  이 외에 시그널을 무시하거나 프로세스 수행 일시 중지/재시작 등을 기본 동작으로 수행한다. </br>
  
  시그널을 무시: 프로세스가 시그널을 무시하기로 지정하면 시스템은 프로세스에 시그널을 전달하지 않는다. </br>
  
  지정된 함수 호출: 프로세스는 시그널의 처리를 위해 미리 함수를 지정해놓고 시그널을 받으면 해당 함수를 호출해 처리한다. </br>
  
  시그널 처리를 위해 지정하는 함수를 시그널 핸들러라고 한다. 시그널을 받으면 기존 처리 작업을 중지한 후 시그널 핸들러를 호출하며, 시그널 핸들러의 동작이 완료되면 기존 처리 작업을 계속 수행한다. </br>
  
  시그널 블록: 프로세스는 특정 부분이 실행되는 동안 시그널이 발생하지 않도록 블로킹할 수 있다. 블로킹된 시그널은 큐에 쌓여 있다가 시그널 블록이 해제되면 전달된다.

  ### 시그널의 종류
  
  기본 처리 중 종료는 프로세스가 그냥 종료되는 것이고, 코어 덤프는 코어 파일을 만들고 종료하는 것이다.

  | 시그널 | 번호 | 기본 처리 | 발생 요건 |
  | :--: | :--: | :--: | :--: |
  | SIGHUP | 1 | 종료 | 행업으로 터미널과 연결이 끊어졌을 때 발생 |
  | SIGINT | 2 | 종료 | 인터럽트로 사용자가 CTRL+C를 입력하면 발생 |
  | SIGQUIT | 3 | 코어 덤프 | 종료 신호로 사용자가 CTRL+\를 입력하면 발생 |
  | SIGILL | 4 | 코어 덤프 | 잘못된 명령 사용 |
  | SIGTRAP | 5 | 코어 덤프 | 추적(trace)이나 브레이크 지점(break point)에서 트랩 발생 |
  | SIGABRT | 6 | 코어 덤프 | abort() 함수에 의해 발생 |
  | SIGIOT | 6 | 코어 덤프 | SIGABRT와 동일 |
  | SIGBUS | 7 | 코어 덤프 | 버스 오류로 발생 |
  | SIGFPE | 8 | 코어 덤프 | 산술 연산 오류로 발생 |
  | SIGKILL | 9 | 종료 | 강제 종료로 발생 |
  | SIGUSR1 | 10 | 종료 | 사용자가 정의해 사용하는 시그널 1 |
  | SIGSEGV | 11 | 코어 덤프 | 세그멘테이션 오류로 발생 |
  | SIGUSR2 | 12 | 종료 | 사용자가 정의해 사용하는 시그널 2 |
  | SIGPIPE | 13 | 종료 | 잘못된 파이프 처리로 발생 |
  | SIGALRM | 14 | 종료 | alarm() 함수에 의해 발생 |
  | SIGTERM | 15 | 종료 | 소프트웨어 종료로 발생 |
  | SIGSTKFLT | 16 | 종료 | 보조 프로세서의 스택 오류로 발생(리눅스에선 지원 안함) |
  | SIGCHLD | 17 | 무시 | 자식 프로세스의 상태가 바뀌었을 때 발생 |
  | SIGCONT | 18 | 무시 | 중지된 프로세스를 재시작할 때 발생 |
  | SIGSTOP | 19 | 중지 | 중지(stop) 시그널로, 이 시그널을 받으면 SIGCONT 시그널을 받을 때까지 프로세스 수행 중단 |
  | SIGTSTP | 20 | 중지 | 사용자가 CTRL+Z로 중지시킬 때 발생 |
  | SIGTTIN | 21 | 중지 | 터미널 입력을 기다리기 위해 중지시킬 때 발생 |
  | SIGTTOU | 22 | 중지 | 터미널 출력을 위해 중지시킬 때 발생 |
  | SIGURG | 23 | 무시 | 소켓에 긴급한 상황이 생기면 발생 |
  | SIGXCPU | 24 | 코어 덤프 | CPU 시간 제한을 초과할 때 발생 |
  | SIGXFSZ | 25 | 코어 덤프 | 파일 크기 제한을 초과할 때 발생 |
  | SIGVTALRM | 26 | 종료 | 가상 타이머가 종료할 때 발생 |
  | SIGPROF | 27 | 종료 | 프로파일 타이머가 종료할 때 발생 |
  | SIGWINCH | 28 | 무시 | 윈도우 크기가 바뀌었을 때 발생 |
  | SIGIO | 29 | 종료 | 비동기식 입출력 이벤트로 발생 |
  | SIGPOLL | SIGIO | 종료 | SIGIO와 동일 |
  | SIGPWR | 30 | 무시 | 전원이 중단되거나 재시작할 때 발생 |
  | SIGSYS | 31 | 코어 덤프 | 잘못된 시스템 호출로 발생 |
  | SIGUNUSED | 31 | 무시 | 향후 사용을 위해 예약된 번호 |

## 2. 시그널 보내기

  시그널을 보내려면 kill(), raise(), abort() 함수를 사용한다. </br>
  kill() 함수 외에 kill 명령도 있는데 프로세스를 종료할 때 사용함.

  kill -9 3255 kill 명령은 인자로 지정한 프로세스에 시그널을 보낸다. PID가 3255인 프로세스에 9번 시그널을 보내라는 의미이다.

    kill(): 시그널 보내기
    ------------------------------------
    #include <sys/types.h>
    #include <signal.h>

    int kill(pid_t pid, int sig);

    * pid_t pid: 시그널을 받을 프로세스의 PID
    * int sig: pid로 지정한 프로세스에 보내는 시그널
    ------------------------------------
    pid에 대응하는 프로세스에 sig로 지정한 시그널을 보낸다.
    pid는 특정 프로세스 또는 프로세스 그룹을 의미한다. pid에 지정한 값에 따라 시그널을 어떻게 보낼 것인지 결정함.

    pid가 0보다 큰 수: pid로 지정한 프로세스에 시그널을 보낸다.
    pid가 -1이 아닌 음수: 프로세스 그룹 ID가 pid의 절대값인 프로세스 그룹에 속하고 시그널을 보낼 권한이 있는 모든 프로세스에 시그널을 보낸다.
    pid가 0: 특별한 프로세스(스케줄러 등)를 제외하고 프로세스 그룹 ID가 시그널을 보내는 프로세스의 프로세스 그룹 ID와 같은 모든 프로세스에 시그널을 보낸다.
    pid가 -1: 시그널을 보내는 프로세스의 유효 사용자 ID가 root(슈퍼 유저)가 아니면, 특별한 프로세스를 제외하고 프로세스의 실제 사용자 ID가 시그널을 보내는 프로세스의 유효 사용자 ID와 같은 모든 프로세스에게 시그널을 보낸다.

    raise(): 시그널 보내기
    ------------------------------------
    #include <signal.h>

    int raise(int sig);

    * int sig: 보내려는 시그널 번호
    ------------------------------------
    호출한 프로세스에 인자로 지정한 시그널을 보낸다. 만약 시그널 핸들러가 호출되면 시그널 핸들러의 수행이 끝날 때까지 raise() 함수는 리턴하지 않는다.

    abort(): 시그널 보내기
    ------------------------------------
    #include <signal.h>

    void abort(void);
    ------------------------------------
    호출한 프로세스에 SIGABRT 시그널을 보낸다. SIGABRT 시그널은 프로세스를 비정상적으로 종료시키고 코어 덤프 파일을 생성한다. SIGABRT 시그널은 최소한 해당 프로세스가 연 파일은 모두 닫는다.

  ## 3. 시그널 기본 처리

    프로세스를 종료하기 전에 처리할 작업이 남아 있거나 특정 시그널은 종료하지 않으려면 시그널을 받을 때 수행할 함수를 지정하면 된다. 이렇게 시그널을 확인해 처리하는 일을 시그널 붙잡기라고 한다.

    signal(): 시그널 핸들러 지정
    ------------------------------------
    #include <signal.h>

    typedef void (*sighandler_t)(int);
    sighandler_t signal(int signum, sighandler_t handler);

    * signum: 시그널 핸들러로 처리하려는 시그널
    * handler: 시그널 핸들러의 함수명
    ------------------------------------
    시그널을 처리하는 가장 단순한 함수. 시그널을 받을 때 해당 시그널을 받을 때 해당 시그널을 처리할 함수나 상수를 지정할 수 있다.
    첫번째 인자인 signum에는 SIGKILL과 SIGSTOP 시그널을 제외한 모든 시그널을 지정할 수 있다. 두번재 인자인 handler에는 signum으로 지정한 시그널을 받았을 때 처리할 방법을 지정함.
    handler에는 다음 세가지중 하나를 지정해야 함.

    시그널 핸들러 주소
    SIG_IGN: 시그널을 무시하도록 지정
    SIG_DFL: 시그널의 기본 처리 방법을 수행하도록 지정

    시스템 V: 시그널을 처리한 후 시그널 처리 방법을 기본 처리 방법(SIG_DFL)으로 재설정한다. 따라서 시그널 처리를 계속하려면 signal() 함수를 호출해 시그널을 처리한 후 다시 signal() 함수를 설정해야 한다.
    BSD: 시그널을 처리한 후 시그널 처리 방법을 기본 처리 방법(SIG_DFL)으로 재설정하지 않는다. 따라서 시그널 핸들러가 계속 동작한다.
    리눅스: 커널의 signal(2) 시스템 콜은 시스템 V와 같은 방식으로 동작한다. 그러나 gcc의 glibc 2부터 signal(3) 함수는 signal(2)를 호출하지 않고 sigaction(2)를 호출해 BSD 형식으로 동작한다.

    sigset(): 시그널 핸들러 지정
    ------------------------------------
    #include <signal.h>

    sighandler_t sigset(int sig, sighandler_t disp);

    * sig: 시그널 핸들러로 처리하려는 시그널
    * disp: 시그널 핸들러의 함수명
    ------------------------------------
    
