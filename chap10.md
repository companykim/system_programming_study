#  chapter 10 파이프

## 1. 이름 없는 파이프

  파이프는 두 프로세스 간에 통신을 할 수 있도록 인터페이스를 제공한다. </br>
  이름 없는 파이프는 부모-자식 프로세스 간에 통신을 할 수 있게 한다.

  파이프는 기본적으로 단방향이기 때문에, 부모 프로세스가 출력한 내용을 자식 프로세스에서 읽을 것인지, </br>
  자식 프로세스가 출력한 내용을 부모 프로세스에서 읽을 것인지 둘 중 한 방향을 선택해야 한다.

  ### 간단한 파이프 생성
    popen(): 파이프 만들기
    -------------------------------------
    #include <stdio.h>

    FILE *popen(const char *command, const char *type);

    * command: 셸 명령
    * type: "r" 또는 "w"
    -------------------------------------
    popen() 함수는 다른 프로세스와 통신하기 위해 파이프를 생성함.
    내부적으로 fork() 함수를 실행해 자식 프로세스를 만들고 command에서 지정한 명령을 exec() 함수로 실행해 자식 프로세스가 수행하도록 한다.
    자식 프로세스가 실행하는 exec() 함수는 이런 형태다. => execl("/bin/sh", "sh", "-c", command, (char *)0);
    자식 프로세스와 파이프를 만들고 mode의 값에 따라 표준 입출력을 입력한다.
    파일 입출력 함수에서 이 파일 포인터를 사용하면 파이프를 읽거나 쓸 수 있다.

    pclose(): 파이프 닫기
    -------------------------------------
    #include <stdio.h>

    int pclose(FILE *stream);
    -------------------------------------
    파일 입출력 함수처럼 인자로 지정한 파이프를 닫는다. 관련된 waitpid() 함수를 수행하며 자식 프로세스들이 종료하기를 기다렸다가 리턴함.

  ### 복잡한 파이프 생성

    popen() 함수를 사용해 파이프를 생성하는 건 간단한 일이지만, 셸을 실행해야 하기 때문에 비효율적이고 주고받을 수 있는 데이터가 제한적이다.
    popen() 함수 대신 pipe() 함수를 사용하면 과정은 복잡해지지만 파이프를 좀 더 효율적으로 생성할 수 있다.

    pipe(): 파이프 만들기
    -------------------------------------
    #include <unistd.h>

    int pipe(int pipefd[2]);

    * pipefd[2]: 파이프로 사용할 파일 기술자(2개)
    -------------------------------------
    pipe() 함수는 인자로 크기가 2인 정수형 배열을 받는다. pipe() 함수는 이 배열에 파일 기술자 2개를 저장한다.
    pipefd[0]은 읽기 전용으로 열고, pipefd[1]은 쓰기 전용으로 연다.

    ### pipe() 함수로 통신하는 과정
    파이프를 생성하면 일반적으로 fork() 함수를 호출해 자식 프로세스를 생성한다. 
    자식 프로세스는 부모 프로세스가 pipe() 함수로 생성한 파일 기술자도 복사한다.
    이 파이프를 이용해 한 프로세스에는 쓰기를 수행하고 다른 프로세스에서는 읽기를 수행하면 통신이 된다.

    1. pipe() 함수를 호출해 파이프에 사용할 파일 기술자를 얻는다. 파이프도 파일의 일종이므로 파일(파이프)을 읽고 쓸 수 있는 파일 기술자가 필요한데, 이를 pipe() 함수가 생성해준다.
    2. fork() 함수를 수행해 자식 프로세스를 생성한다. 이때 pipe() 함수에서 생성한 파일 기술자도 자식 프로세스로 복사된다. 
    3. 파이프는 단방향 통신이므로 통신 방향을 결정한다. 예를 들어, 부모 프로세스는 쓰기를 하고 자식 프로세스는 읽기를 한다고 가정하면, 자식 프로세스는 읽기만 할것이므로 쓰기용 파일 기술자인 fd[1]을 닫는다.
    반대로 부모 프로세스는 쓰기만 할것이므로 읽기용 파일 기술자인 fd[0]을 닫는다.
    만약 파이프의 쓰기 부분이 닫혀 있다면 파이프에서 읽으려고 할때 0이나 EOF가 리턴된다. 파이프의 읽기 부분이 닫혀 있다면 파이프에 쓰려고 할때 SIGPIPE 시그널이 발생한다.

  ### 양방향 파이프의 활용
    파이프를 이용해 양방향 통신을 하려면 파이프를 2개 생성하면 된다.

## 2. 이름 있는 파이프

  이름 없는 파이프는 부모-자식 프로세스 간에만 통신할 수 있다는 단점이 있다. 부모-자식 프로세스는 서로의 존재를 알고 있기 때문에 파이프에 별도의 이름을 붙여 구별하지 않아도 된다. </br>
  하지만 부모-자식 프로세스 관계가 아닌 독립적인 프로세스들은 서로의 존재를 알 수 없기 때문에 파이프명이 있어야 파이프를 이용할 수 있다. 이것을 이름 있는 파이프라고 하며, 특수 파일의 한 종류로 FIFO라고도 한다.

   이름 있는 파이프는 몯느 프로세스가 이 파이프명을 이용해 통신할 수 있다. </br>
   FIFO로 통신하려면 우선 FIFO 특수 파일을 생성하고 파일 입출력 함수를 사용하면 된다. </br>
   즉, 한 프로세스가 FIFO로 사용할 특수 파일을 생성하면 이 파일의 이름을 알고 있는 다른 프로세스가 같은 FIFO를 이용해 통신을 수행할 수 있다.

   ### 명령으로 FIFO 파일 생성
     명령으로 FIFO 파일을 생성하려면 mknod나 mkinfo 명령을 사용한다.

     mknod 명령: FIFO 특수 파일 생성
     mknod 명령은 FIFO 파일뿐만 아니라 특수 파일도 생성하는 명령이다.
     ------------------
     mknod 파일명 p 예) mknod HAN_FIFO p
     ------------------
     mknod 명령을 사용할 때는 FIFO 파일의 이름과 FIFO 파일을 생성하라는 의미인 p를 지정한다. 
     p는 FIFO 파일을 의미한다.

     mkfifo 명령: FIFO 파일 생성
     FIFO 파일만 생성하는 명령이다. 
     ------------------
     mkfifo [-m mode] ... NAME ... 예) mkfifo -m 0644 BIT_FIFO
     ------------------
     -m 옵션은 새로 생성되는 FIFO 파일의 접근 권한을 지정한다. 생략하면 unmask 값에 따라 기본 권한을 설정한다.

  ### 함수로 FIFO 파일 생성하기

      mknod(): 특수 파일 생성
      ---------------------------
      #include <sys/types.h>
      #include <sys/stat.h>
      #include <fcntl.h>
      #include <unistd.h>

      int mknod(const char *pathname, mode_t mode, dev_t dev);

      * pathname: 특수 파일을 생성할 경로
      * mode: 특수 파일의 종류와 접근 권한 지정
      * dev: 블록/문자 장치 설정값
      ---------------------------
      mknod() 함수는 첫번째 인자인 pathname으로 지정한 경로에 특수 파일을 생성한다. 두번째 인자인 mode에는 특수 파일의 종류와 접근 권한을 지정한다.
      
      mode에 지정하는 특수 파일의 종류
      S_IFIFO: FIFO 특수 파일
      S_IFCHR: 문자 장치 특수 파일
      S_IFBLK: 블록 장치 특수 파일
      S_IFREG: 일반 파일
      S_IFSOCK: 유닉스 도메인 소켓 파일

      mode에 지정하는 접근 권한은 0777과 같이 숫자 모드를 직접 사용하는 것이 편하다.
      세번째 인자인 dev는 생성하려는 특수 파일이 블록 장치 특수 파일이나 문자 장치 특수 파일일때만 의미가 있다.

      mkfifo(): FIFO 파일 생성
      ---------------------------
      #include <sys/types.h>
      #include <sys/stat.h>

      int mkfifo(const char *pathname, mode_t mode);

      * pathname: FIFO 파일을 생성할 경로
      * mode: 접근 권한 지정
      ---------------------------
      pathname으로 지정한 경로에 접근 권한을 지정해 FIFO 파일을 생성한다.

  ### FIFO로 데이터 주고받기

      명령이나 함수로 FIFO 파일을 생성하면 저수준 파일 입출력 함수로 이 파일을 읽거나 쓸 수 있다.
      open() 함수로 FIFO 파일을 열 때는 O_NONBLOCK 옵션의 영향을 받는다. O_NONBLOCK 옵션이 설정되어 있지 않으면 다른 프로세스가 읽기 위해 열 때까지, 쓰기 위한 open() 함수는 블로킹된다.
      반대도 O_NONBLOCK 옵션이 설정되어 있으면 open() 함수는 즉시 리턴한다. FIFO에서 데이터를 읽으려는 프로세스가 없는데 쓰기 위해 open() 함수를 호출하면 오류가 발생한다.

      FIFO도 파이프와 마찬가지로 단방향이기 때문에 FIFO 파일을 읽거나 쓰기 위해 열 경우에는 반드시 읽기 전용(O_RDONLY)이나 쓰기 전용(O_WRONLY)으로만 열어야 한다. 읽고 쓰기용(O_RDWR)으로는 열 수 없다.
      FIFO 파일은 양쪽이 같이 열려야 읽거나 쓸 수 있다. 한 프로세스가 FIFO를 열기 위해 열면 다른 프로세스가 같은 FIFO 파일을 쓰기 위해 열 때까지 기다린다.
