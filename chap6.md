# chapter 6 프로세스 정보

## 1. 프로세스의 개념

  ### 프로세스의 정의
  실행 중인 프로그램을 의미한다. 프로세서가 처리 중인 프로그램이기도 하다. </br>
  컴파일을 통해 생성된 실행 파일이든, 인터프리터 방식으로 동작하는 스크립트 파일이든 상관없이 이들을 실행하면 프로세스가 된다. </br>
  소스 파일을 작성하고 컴파일해서 실행 파일을 생성한다. 실행 파일을 메모리에 적재해 실행하면 프로세스가 된다. </br>

  ### 프로세스의 구조
  텍스트 영역: 실행 코드를 저장한다. 프로세스 실행 중에 크기가 변하지 않는 고정 영역에 속한다. </br>
  데이터 영역: 프로그램에서 정의한 전역 변수를 저장한다. 전역 변수는 프로그램을 작성할 때 크기가 고정되므로 고정 영역에 할당된다. </br>
  힙 영역: 프로그램 실행 중에 동적으로 메모리를 요청하는 경우에 할당되는 영역으로, 빈 영역->할당->할당 해제처럼 상태가 변하는 가변 영역이다. </br>
  스택 영역: 프로그램에서 정의한 지역 변수를 저장하는 메모리 영역으로, 지역 변수를 정의한 부분에서 할당해 사용한다. </br>
  빈 공간: 스택이나 힙과 같이 가변적인 메모리 할당을 위해 유지하고 있는 빈 메모리 영역이다. 프로세스에 할당된 빈 메모리 영역이 모두 소진되면 메모리 부족으로 프로그램 실행이 중된될 수도 있다.

  ### 프로세스 상태 변화
  프로세스는 실행되는 동안 계속 실행 상태로 있는 것은 아니다. </br>
  1. 프로세스는 사용자 모드에서 먼저 실행된다. </br>
  2. 사용자 모드에서 시스템 호출을 하면 커널 모드로 전환되어 실행된다.
  3. 수면 중이던 프로세스가 깨어나 실행 대기 상태가 되면 바로 실행할 수 있도록 준비한다.
  4. 커널 모드에서 실행 중 입출력 완료를 기다릴 때와 같이 더 이상 실행을 계속할 수 없을 때 수면 상태로 전환된다.

  CPU는 한번에 프로세스 하나만 실행할 수 있으므로 실제로는 시스템에서 실행 중인 많은 프로세스 중 하나만 1이나 2의 상태에 있고 나머지는 3이나 4의 상태에 있게 된다. </br>
  입출력을 완료했을 때 혹은 다른 프로세스가 종료되기를 기다릴 때는 프로세스가 잠든다. 이를 수면 상태라고 한다. </br>
  수면 상태에서 기다리다가 해당 사건이 발생하면 깨어나 실행 대기 상태로 전환된다. 실행 대기 상태는 CPU를 사용할 수 있을 때까지 기다리는 상태로 스케줄링에 따라 실행된다. </br>
  프로세스의 상태를 적절히 전환하는 일은 커널의 프로세스 관리 기능에 해당한다. </br>

  ### 프로세스 목록 보기
  현재 실행 중인 프로세스의 목록을 보려면 ps 명령을 사용한다. 아무 옵션없이 ps 명령만 실행하면 현재 터미널에서 실행한 프로세스만 출력된다. </br>
  시스템에서 동작하고 있는 전체 프로세스를 보려면 -ef 옵션을 지정한다. </br>

  ### 시스템 정보 보기
  ps 이외에도 top 명령이 있다. 이 명령은 현재 실행 중인 프로세스를 주기적으로 확인해 출력한다. </br>
  단순히 프로세스 목록만이 아니라 시스템 부하 평균 정보를 메모리, 스왑, 현재 실행 중인 프로세스 수 등의 정보로 보여준다. </br>
  메모리와 스왑 등에 관한 정보를 직접 검색하려면 sysinfo() 함수를 사용한다. </br>

    sysinfo(): 메모리와 스왑 상태 검색
    -----------------------------------------
    #include <sys/sysinfo.h>

    int sysinfo(struct sysinfo *info);

    * info: 검색 결과를 리턴하는 sysinfo 구조체의 주소
    -----------------------------------------
    struct sysinfo {
      long uptime; 시스템 부팅 후 경과된 시간을 초 단위로 저장한다.
      unsigned long loads[3]; 시스템 부하 평균을 저장하는 배열로, 1분, 5분, 15분 기준으로 계산해 저장한다.
      unsigned long totalram; 사용 가능한 총 메모리 크기를 저장한다.
      unsinged long freeram; 사용 가능한 메모리의 크기를 저장한다.
      unsigned long sharedram; 공유 메모리의 크기를 저장한다.
      unsigned long bufferram; 버퍼가 사용하는 메모리의 크기를 저장한다.
      unsinged long totalswap; 스왑 영역의 총 크기를 저장한다.
      unsigned long freeswap; 사용 가능한 스왑 영역의 크기를 저장한다.
      unsigned long short procs; 현재 실행 중인 프로세스의 수를 저장한다.
      unsigned long totalhigh; 사용자에 할당된 메모리의 총 크기를 저장한다.
      unsigned long freehigh; 사용 가능한 사용자 메모리의 크기를 저장한다.
      unsigned int mem_unit; 메모리 크기를 바이트 단위로 저장한다.
      char _f[20-2*sizeof(long)-sizeof(int)]; 64바이트 크기를 맞추기 위한 패딩이다.
    };

## 2. 프로세스 식별

  프로세스를 식별하기 위한 프로세스 ID(PID)가 있다. 그리고 관련 프로세스가 모여 프로세스 그룹을 구성한다.

  ### PID 검색
    PID는 0부터 시작한다. 0번 프로세스는 sched(스케줄러)로, 프로세스에 CPU 시간을 할당하는 역할을 한다.
    0번 프로세스는 커널의 일부분이므로 별도의 실행 파일은 없다.
    1번 프로세스는 init이다. 프로세스가 새로 생성될 때마다 기존 PID와 중복되지 않은 번호가 할당된다.

    getpid(): PID 검색
    -----------------------------------------
    #include <sys/types.h>
    #include <unistd.h>

    pid_t getpid(void);
    -----------------------------------------
    이 함수를 호출한 프로세스의 PID를 리턴한다.

    getppid(): PPID 검색
    -----------------------------------------
    #include <sys/types.h>
    #include <unistd.h>

    pid_t getppid(void);
    -----------------------------------------
    0번 프로세스를 제외한 모든 프로세스에는 자신을 생성한 프로세스가 있다. 이를 부모 프로세스라 하는데, 부모 프로세스의 PID를 PPID라고 한다.
    0번 프로세스가 부모인 프로세스로 [kthreadd]가 있는데 이 프로세스는 쓰레드를 관리한다.

  ### 프로세스 그룹
    관련 있는 프로세스를 묶은 것이고, 프로세스 그룹 ID(PGID)를 부여 받는다.
    작업 제어 기능을 제공하는 C 셸이나 배시 셸은 명령을 파이프로 연결함으로써 프로세스 그룹으로 묶어 한 작업으로 처리할 수 있다.

    프로세스 그룹 리더
    프로세스의 그룹 리더는 변경될 수 있으며, 리더 프로세스가 변경되면 PGID도 변경된다.

    getpgrp(), getpgid(): PGID 검색
    -----------------------------------------
    #include <sys/types.h>
    #include <unistd.h>

    pid_t getpgrp(void);
    pid_t getpgid(pid_t pid);

    * pid: PGID를 구하려는 프로세스의 ID
    -----------------------------------------
    getpgrp()는 이 함수를 호출하는 프로세스가 속한 그룹의 PGID를 리턴함.
    getpgid()는 pid 인자로 지정한 프로세스가 속한 그룹의 PGID를 리턴함.

    setpgid(): pgid 변경
    -----------------------------------------
    #include <sys/types.h>
    #include <unistd.h>

    int setpgid(pid_t pid, pid_t pgid);

    * pid: 프로세스 그룹에 속한 프로세스의 ID
    * pgid: 새로 지정할 PGID
    -----------------------------------------
    pid가 가리키는 프로세스의 PGID를 pgid로 지정한 값으로 지정한다.
    pid와 pgid가 같다면 pid에 해당하는 프로세스가 그룹 리더가 된다.

  ### 세션
    세션은 사용자가 로그인해 작업하고 있는 터미널 단위로 프로세스 그룹을 묶은 것이다.
    프로세스 그룹이 관련 있는 프로세스를 그룹으로 묶은 개념이면, 세션은 관련 있는 프로세스 그룹을 모은 개념이다.

    getsid(): 세션 검색
    -----------------------------------------
    #include <sys/types.h>
    #include <unistd.h>

    pid_t getsid(pid_t pid);

    * pid: 자신이 속한 세션의 ID를 구하려는 프로세스의 ID
    -----------------------------------------
    프로세스가 새로운 세션을 생성하면 해당 프로세스는 세션 리더가 되고 세션 리더의 PID는 세션 ID가 된다.
    getsid()는 pid로 지정한 프로세스가 속한 세션의 ID를 리턴한다.

    setsid(): 세션 생성
    -----------------------------------------
    #include <sys/types.h>
    #include <unistd.h>

    pid_t setsid(void);
    -----------------------------------------
    setsid()는 새로운 세션을 만들 수 있다.
    setsid()를 호출하는 프로세스가 프로세스 그룹 리더가 아니면 새로운 세션과 프로세스 그룹의 유일한 프로세스가 된다.

  ## 3. 프로세스 실행 시간 측정
    프로세스를 실행하면 CPU나 메모리 같은 시스템 자원을 사용한다. </br>
    시간 정보를 이용해 프로세스 실행 시간을 측정할 수 있으며, 이것은 시스템 사용 요금을 결정하는데 활용할 수 있다.

    ### 프로세스 실행 시간의 구성
    프로세스 실행 시간은 시스템 실행 시간과 사용자 실행 시간으로 구분할 수 있다.
    시스템 실행 시간은 프로세스에서 커널의 코드를 수행한 시간이며, 시스템 호출로 소비한 시간을 의미함.
    사용자 실행 시간은 사용자 모드에서 프로세스를 실행한 시간이며, 프로그램 내부의 함수나 반복문처럼 사용자가 작성한 코드를 실행하는데 걸린 시간이다.
    프로세스 실행 시간 = 시스템 실행 시간 + 사용자 실행 시간

    ### 프로세스 실행 시간 측정
    time() 함수를 사용하면 프로세스 실행에 소요된 사용자 실행 시간과 시스템 실행 시간을 알 수 있다. 특히 모든 자식 프로세스의 실행 시간을 함께 알 수 있다.
    time() 함수는 실행 결과를 tms 구조체에 저장하고 클록 틱을 리턴한다.

    tms 구조체
    struct tms {
      clock_t tms_utime; times() 함수를 호출한 프로세스가 사용한 사용자 모드 실행 시간
      clock_t tms_stime; times() 함수를 호출한 프로세스가 사용한 시스템(커널) 모드 실행 시간
      clock_t tms_cutime; times() 함수를 호출한 프로세스의 모든 자식 프로세스가 사용한 사용자 모드 실행 시간과 tms_utime의 합계 시간
      clock_t tms_cstime; times() 함수를 호출한 프로세스의 모든 자식 프로세스가 사용한 시스템 모드 실행 시간과 tms_stime의 합계 시간
    }

    times(): 실행 시간 측정
    -----------------------------------------
    #include <sys/times.h>

    clock_t times(struct tms *buf);

    * buf: 실행 시간을 저장할 tms 구조체의 주소
    -----------------------------------------
    프로세스 실행 시간을 인자로 지정한 tms 구조체에 저장 times() 함수가 알려주는 시간 단위는 시계의 클록 틱이다.

  ## 4. 환경 변수의 활용

    프로세스가 실행되는 기본 환경은 사용자의 로그인명, 로그인 셸, 터미널에 설정된 언어, 경로명 등을 포함한다. 환경 변수로 정의되어 있음.
    모든 프로세스는 부모 프로세스에서 기본 환경을 물려받는다. 셸은 환경 변수를 검색, 추가, 수정할 수 있도록 한다.

    ### 환경 변수의 이해
    환경 변수는 '환경 변수명=값' 형태로 구성되며, 변수명은 관례적으로 대문자를 사용함.
    셸에서 값을 설정하거나 변경할 수 있으며 함수를 이용해 읽거나 설정할 수도 있다.
    env 명령을 사용해 셸의 환경 설정을 볼 수 있다.
    셸의 종류, 현재 디렉토리 위치, 로그인 ID, 홈 디렉토리 등의 정보가 환경 변수에 정의되어 있다.

    ### 환경 변수 사용

    environ: 전역 변수 사용
    -----------------------------------------
    #include <unistd.h>

    extern char **environ;
    -----------------------------------------
    전역 변수 environ은 환경 변수 전체에 대한 포인터, 이 변수를 사용해 환경 변수를 검색할 수 있다.

    ### main() 함수 인자 사용
    아무 인자 없이 사용할 수도 있고 인자를 지정해 사용할 수도 있다.
    int main(int argc, char **atgv, char **envp)
    리눅스에서는 환경 변수를 main()의 세번째 인자로 지정해 사용할 수 있다.
    전역 변수 environ이나 main() 함수의 인자로 환경 변수를 활용할 때 특정 환경 변수의 값만 검색하는건 불편하기 때문에 특정 환경 변수의 값만 검색하거나 설정할 수 있는 별도의 함수가 있어야 함.

    getenv(): 환경 변수 검색
    -----------------------------------------
    #include <stdlib.h>

    char *getenv(const char *name);

    * name: 환경 변수명
    -----------------------------------------
    인자로 지정한 환경 변수가 설정되어 있는지 검색해 결과값을 저장하고 주소를 리턴함.

    putenv(): 환경 변수 설정
    -----------------------------------------
    #include <stdlib.h>

    int putenv(char *string);

    * string: 설정할 환경 변수와 값으로 구성한 문자열
    -----------------------------------------
    프로그램에서 환경 변수를 설정할 수 있다. 설정할 환경 변수를 '환경 변수명=값'형태로 지정하면 됨.
    기존의 환경 변숫값은 변경하고, 새로운 환경 변수는 malloc()으로 메모리를 할당해 추가한다.

    setenv(): 환경 변수 설정
    -----------------------------------------
    #include <stdlib.h>

    int setenv(const char *name, const char *value, int overwrite);

    * name: 환경 변수명
    * value: 환경 변숫값
    * overwrite: 덮어쓰기
    -----------------------------------------
    putenv()와 다른점은 환경 변수와 환경 변숫값을 각각 인자로 지정한다. setenv() 함수는 name에 지정한 환경 변수에 value의 값을 설정한다.
    overwrite는 name으로 지정한 환경 변수에 이미 값이 설정되어 있을 경우 덮어쓰기 여부를 지정한다.

    unsetenv(): 환경 변수 설정 삭제
    -----------------------------------------
    #include <stdlib.h>

    int unsetenv(const char *name);

    * name: 환경 변수명
    -----------------------------------------
    name에 지정한 환경 변수를 삭제한다. 현재 환경에 name으로 지정한 환경 변수가 없으면 기존 환경을 변경하지 않는다.
