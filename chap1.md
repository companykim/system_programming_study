# chapter 1 리눅스/유닉스 시스템 프로그래밍의 이해</br>
유닉스와 호환되는 리눅스는 오픈 소스로 제공되는 운영체제이다.</br>
리눅스/유닉스 시스템 프로그래밍은 시스템에서 제공하는 시스템 호출을 아용해 프로그램을 작성하는 것이다.</br>
즉, 개발자는 시스템이 제공하는 시스템 호출에 관해 반드시 학습해야 한다.

## 1. 리눅스/유닉스 시스템 표준 </br>
리눅스는 POSIX와 단일 유닉스 규격과의 호환성을 유지하기 위해 노력하고 있다. </br>
POSIX: 유닉스에 기반을 두고 있는 표준 운영체제 인터페이스

시스템 프로그래밍 </br>
시스템에서 제공하는 시스템 호출을 사용해 프로그램을 작성하는 것

시스템 호출: 파일 시스템 접근, 사용자 정보, 시스템 정보, 시스템 시간 정보, 네트워킹 등 리눅스 시스템에서 제공되는
서비스를 이용해 프로그램을 구현할 수 있도록 제공되는 프로그래밍 인터페이스 </br>
(결과값을 리턴하는 경우도 있지만, 대부분은 시스템 호출의 성공이나 실패를 알려주는 정숫값을 리턴한다.)

## 2. 라이브러리 함수 </br>
라이브러리는 미리 컴파일된 함수를 묶어서 제공하는 특수한 형태의 파일이다. 라이브러리 함수는 그것이 포함되어 있는 함수이다. </br>
함수를 묶어서 라이브러리를 만드는 이유는 자주 사용하는 기능을 독립적으로 구현함으로써 프로그램 개발과 디버깅을 쉽게 하고 컴파일이 빨라지기 때문이다. </br>
리눅스 시스템에서는 /usr/lib에 위치한다. 확장자는 .a, .so이고, 이름은 일반적으로 lib로 시작한다. lib*.a는 정적 라이브러리, lib*.so는 공유 라이브러리이다. </br>
정적 라이브러리는 프로그램을 컴파일 할 때 같이 적재되어 실행 파일을 구성한다. 실행 파일에 라이브러리 코드가 포함되기 때문에 그만큼 크기가 커진다. </br>
공유 라이브러리는 실행 파일에 포함되지 않는다. 공유 라이브러리를 이용해 생성한 실행 파일은 실행 시에 해당 라이브러리가 메모리에 적재된다. </br>
공유 라이브러리는 메모리를 효율적으로 사용하기 위해 많이 사용한다. </br>
시스템 호출은 커널의 해당 모듈을 직접 호출해 작업하고 결과를 리턴한다. 하지만 라이브러리 함수는 커널 모듈을 직접 호출하지 않는다. </br>
라이브러리 함수에서 커널의 서비스를 이용하려면 함수 내부에서 시스템 호출을 사용한다. </br>
리눅스에서는 매뉴얼을 검색하고 도움을 얻으려면 man 명령을 이용하면 된다. </br>
매뉴얼은 항목의 종류에 따라 섹션이 구분되는데 일반적인 명령은 섹션 1, 시스템 호출은 2, 라이브러리 함수는 3이다. </br>

오류 처리 방법 </br>
시스템 호출이 성공적으로 수행되면 0을 리턴, 실패하면 -1을 리턴하고 전역변수 errno에 오류 코드를 저장 </br>

## 3. 시스템 도구 </br>
### 기본 명령 </br>
로그인/로그아웃 명령 </br>
| 명령 | 기능 | 예제 |
| :--: | :--: | :--: |
| telnet/ssh | 리눅스 시스템에 접속 | telnet ***.co.kr/ssh ***.co.kr |
| exit/logout | 리눅스 시스템 접속 해제 | exit/logout |

파일/디렉토리 명령 </br>
| 명령 | 기능 | 주요 옵션 | 예제 |
| :--: | :--: | :--: | :--: |
| pwd | 현재 디렉토리 경로 출력 | - | pwd |
| ls | 디렉토리 내용 출력 | -a: 숨김 파일 출력/ -l: 파일 상세 정보 출력 | ls -a/tmp / ls -l |
| cd | 디렉토리 이동 | - | cd/tmp / cd ~han01 |
| cp | 파일 복사 / 디렉토리 복사 | -r: 디렉토리 복사 | cp a.txt b.txt / cp -r dir1 dir2 |
| mv | 파일명/디렉토리명 변경 / 파일/디렉토리 이동 |  | mv a.txt b.txt / mv dir1 dir2 / mv a.txt dir1 |
| rm | 파일 삭제 / 디렉토리 삭제 | -r: 디렉토리 삭제 | rm a.txt / rm -r dir1 |
| mkdir | 디렉토리 생성 | - | mkdir dir1 |
| rmdir | 빈 디렉토리 삭제 | - | rmdir dir1 |
| cat | 파일 내용 출력 | - | cat a.txt |
| more | 화면 크기 단위로 파일 내용 출력 | - | more a.txt |
| chmod | 파일/디렉토리 접근 권한 변경 | - | chmod 755 a.exe / chmod go+x a.exe |
| grep | 패턴 검색 | - | grep abcd a.txt |

프로세스 명령 </br>
| 명령 | 기능 | 주요 옵션 | 예제 |
| :--: | :--: | :--: | :--: |
| ps | 현재 실행 중인 프로세스의 정보 출력 | -ef: 모든 프로세스의 상세 정보 출력 | ps / ps -ef / ps -ef \ grep ftp |
| kill | 프로세스 강제 종료 | -9: 강제 종료 | kill 5000 / kill -9 5001 |

기타 명령 </br>
| 명령 | 기능 | 주요 옵션 | 예제 |
| :--: | :--: | :--: | :--: |
| su | 사용자 계정 변경 | -: 변경할 사용자의 환경 초기화 파일 실행 | su / su - / su - han02 |
| tar | 파일/디렉토리 묶기 | cvf: tar 파일 생성 / tvf: tar 파일 내용 보기 / xvf: tar 파일 풀기 | tar cvf a.tar * / tar tvf a.tar / tar xvf a.tar |
| whereis / which | 파일 위치 검색 | - | whereis is / which telnet |

vi 편집기 내부 명령 </br>
| 기능 | 명령 | 기능 | 명령 |
| :--: | :--: | :--: | :--: |
| 입력 모드 전환 | i, a, o, O | 명령 모드 전환 | Esc |
| 커서 이동 | j, k, h, l 또는 방향키 | 행 이동 | #G(50G, 143G 등) 또는 :행 번호 |
| 한 글자 수정 | r | 여러 글자 수정 | #s(5s, 7s 등) |
| 단어 수정 | cw | 명령 취소 | u, U |
| 검색해 수정 | :%s/aaa/bbb/g | 복사 | #yy(5yy, 10yy 등) |
| 붙이기 | p | 커서 이후 삭제 | D(shift + d) |
| 글자 삭제 | x, #x(3x, 5x 등) | 행 삭제(잘라내기) | dd, #dd(3dd, 4dd 등) |
| 저장하고 종료 | :wq! 또는 ZZ | 저장하지 않고 종료 | :q! |
| 행 붙이기 | J(shift + j) | 화면 다시 표시 | ctrl + l(소문자 L) |
| 행 번호 보이기 | :set nu | 행 번호 없애기 | :set nonu |

### 컴파일 환경 
  컴파일이란 텍스트로 작성한 프로그램을 시스켐이 이해할 수 있는 기계어로 변환하는 과정 </br>
  컴파일 과정과 라이브러리 링크 과정을 하나로 묶어서 수행하는 것을 의미

  GNU C 컴파일러: gcc </br>
  리눅스에는 기본적으로 gcc 설치가 가능 </br>
  프로그램을 컴파일해 실행 파일을 생성한다. </br>
  gcc [옵션][파일명] </br>
  옵션: -c: 오브젝트 파일 (.o)만 생성 </br>
  -o 실행 파일명: 지정한 이름으로 실행 파일을 생성한다. 기본 실행 파일명은 a.out < /br>
  gcc는 기본적으로 /usr/bin 디렉토리에 설치됨.

  Makefile과 make </br>
  Makefile은 컴파일 명령, 소스 파일을 컴파일하는 방법, 링크할 파일, 실행 파일명 등을 설정하는 파일이다. </br>
  make 명령은 Makefile을 읽고 이 파일에서 지정한대로 컴파일을 실행해 실행 파일을 생성한다. </br>
  실행 파일을 생성한 후에는 변경사항이 있는 파일만 재컴파일해 실행 파일을 생성한다.

### 오류 처리 함수
  오류 코드를 메시지로 변환해 출력한다.

  --------------------------
  perror(): 오류 메시지 출력
  #include <stdio.h>

  void perror(const char *s);

  * s: 출력할 문자열
  --------------------------
  perror() 함수는 errno에 저장된 값을 읽어 이에 해당하는 메시지를 표준 오류로 출력한다.

  --------------------------
  strerror(): 오류 메시지 출력
  #include <string.h>

  char *strerror(int errnum);

  * errnum: errno에 저장된 값
  --------------------------
  strerror() 함수는 ANSI C에서 추가로 정의한 함수다. 함수의 인자로 errno에 저장된 값을 받아 오류 메시지를 리턴함.

### 동적 메모리 할당
  프로그램 실행 도중에 필요한 메모리 공간을 할당하고 더 이상 사용하지 않으면 해당 공간을 해제하는 것. </br>
  이를 사용하면 필요한 데이터의 양에 따라 메모리 공간을 효율적으로 사용 가능.

  --------------------------
  malloc(): 메모리 할당
  #include <stdlib.h>

  void *malloc(size_t size);

  * size: 할당받을 메모리 크기
  --------------------------
  malloc() 함수는 인자로 지정한 크기의 메모리를 할당하는데 성공하면 메모리의 시작 주소를 리턴한다.</br>
  할당된 메모리에는 어떤 형태의 데이터도 저장할 수 있다.

  --------------------------
  calloc(): 메모리 할당과 초기화
  #include <stdlib.h>

  void *calloc(size_t nmemb, size_t size);

  * nmemb: 배열 요소 개수
  * size: 각 배열 요소의 크기(바이트)
  --------------------------
  nmemb x size바이트 크기의 배열을 저장할 메모리를 할당한다. </br>
  할당된 메모리를 0으로 초기화한다.

  --------------------------
  realloc(): 메모리 추가 할당
  #include <stdlib.h>

  void *realloc(void *ptr, size_t size);

  * ptr: 할당받은 메모리를 가리키는 포인터
  * size: 할당할 메모리의 크기
  --------------------------
  이미 할당받은 메모리에 추가로 메모리를 할당할 때 사용한다. </br>
  이전에 할당받은 메모리와 추가할 메모리를 합한 크기의 메모리를 새롭게 할당하고 주소를 리턴한다. </br>
  이전 메모리의 내용을 새로 할당된 메모리로 복사한다.

  --------------------------
  free(): 메모리 해제
  #include <stdlib.h>

  void free(void *ptr);

  * ptr: 해제할 메모리 주소
  --------------------------
  사용을 마친 메모리를 해제하고 반납한다.

### 명령형 인자
  명령행은 리눅스 시스템에서 사용자가 명령을 입력하는 행이다. </br>
  프롬프트가 나타나고 커서가 사용자 입력을 기다리고 있는 행이다. </br>
  명령행 인자는 사용자가 명령행에서 명령을 실행할 때 해당 명령(실행파일명)과 함께 지정하는 인자를 말한다. </br>
  명령행 인자는 명령의 옵션, 옵션의 인자, 명령의 인자로 구성됨. </br>
  명령행 인자는 자동으로 프로그램의 main() 함수에 전달된다.
  int main(int argc, char *argv[]) {...}

  getopt(): 옵션 처리 </br>
  POSIX.2, XPG4, SUS, SUSv2, SUSv3
  #include <unistd.h>
  
  int getopt(int argc, char * const argv[], const char *optstring);
  extern char *optarg;
  extern int optind, opterr, optopt;
    
  명령행 인자로 전달된 옵션을 편리하게 처리하도록 제공되는 함수다. </br>
  리눅스는 POSIX를 따라 unistd.h를 선언한다. </br>
  argv에 optstring에 지정된 옵션과 동일한 옵션 문자가 있으면 해당 문자를 리턴함.

### 리눅스 명령 기본 규칙
  getopt() 함수로 옵션을 처리하려면 POSIX에서 정의한 명령에 대한 기본 규칙을 준수해서 명령행 인자를 입력해야 한다. </br>
  POSIX에서 정한 규칙은 다음과 같다. (3~7, 9, 10, 15~18번 까지가 getopt()에 대한 내용)

  [규칙 3] 옵션의 이름은 한 글자여야 한다.
  [규칙 4] 모든 옵션의 앞에는 하이픈(-)이 있어야 한다.
  [규칙 5] 인자가 없는 옵션은 하나의 -다음에 묶여서 올 수 있다. 예) -xvf
  [규칙 6] 옵션의 첫번째 인자는 공백이나 탭으로 띄고 입력해야 한다. 예) -l/tmp
  [규칙 7] 인자가 있어야 하는 옵션에서 인자를 생략할 수 없다.
  [규칙 9] 명령행에서 모든 옵션은 명령의 인자보다 앞에 와야 한다. 예) ls -l/tmp와 같이 입력해야 한다. ls /tmp -l과 같이 입력할 수는 없다.
  [규칙 10] 옵션의 끝을 나타내기 위해 --을 사용할 수 있다.
  명령어 -a --긴 옵션1 -c 옵션 인자 -f 옵션 인자 --긴 옵션2=옵션 인자
            --긴 옵션3 옵션 인자 파일명
  [규칙 15] 긴 옵션은 -- 다음에 와야 한다. 옵션명으로는 문자, 숫자, -만 사용할 수 있으며, -으로 연결한 1~3개의 단어를 사용할 수도 있다.
  [규칙 16] '--이름=인자' 형태는 긴 옵션 사용에서 옵션의 인자를 상세하게 지정할 때 사용해야 한다. (예에서 긴 옵션2의 경우). '--이름 인자'형태도 가능하다.(예에서 긴 옵션3의 경우)
  [규칙 17] 모든 명령은 긴 옵션 --version(V도 지원)과 --help(-?도 지원)를 표준으로 지원해야 한다.
  [규칙 18] 모든 짧은 옵션에 대응하는 긴 옵션이 있어야 하고, 긴 옵션에도 대응하는 짧은 옵션이 있어야 한다.
