# chapter 4 파일 입출력

리눅스에서 파일을 읽고 쓰는 방법은 저수준 파일 입출력, 고수준 파일 입출력으로 분류한다.

## 1. 저수준 파일 입출력

   바이트 단위로 입출력을 수행하므로 해당 함수 자체의 구조는 단순하다.

   ### 파일 기술자
   
     현재 열려 있는 파일을 구분할 목적으로 시스템에서 붙여놓은 번호이며, 열린 파일을 참조하는 데 사용하는 지시자 역할을 한다.
     정숫값이며, open() 함수를 사용해 파일을 열 때 부여된다.
     0번: 표준 입력, 1번: 표준 출력, 2번: 표준 오류
     0번은 키보드, 1,2번은 모니터 화면을 의미한다.
     프로세스가 파일을 열 때 파일 기술자에는 0번부터 순서대로 가장 작은 번호가 자동 할당된다.
     물론 처음 동작시 0,1,2번은 자동 할당되기에 3번부터 할당된다.

  ### 파일 생성과 열고 닫기
    파일을 연다는 것은 파일의 내용을 읽거나 파일에 내용을 쓸 수 있는 상태로 변경하는 것을 의미한다.
    작업을 완료하면 파일을 닫아야 한다. 그래야 파일의 내용을 하드 디스크에 온전히 기록하고 파일이 사용한 버퍼 등을 반납할 수 있다.

    open(): 파일 열기
    ---------------------------------------------------------
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);

    * pathname: 열려는 파일이 있는 경로
    * flags: 파일 상태 플래그
    * mode: 접근 권한
    --------------------------------------------------------
    open() 함수는 pathname에 지정한 파일을 flags에 지정한 상태 플래그의 값에 따라 열고 파일 기술자를 반환한다. 
    파일의 상태를 조정하는 flags 값은 man 명령으로 확인할 수 있다.
    O_RDONLY
    O_WRONLY
    O_RDWR
    O_CREAT
    O_EXCL
    O_APPEND
    O_TRUNC
    O_SYNC/O_DSYNC

    플래그는 OR(|) 연산자로 지정 가능
    쓰기 전용으로 열 때(파일이 있는 경우) : O_WRONLY | O_TRUNC
    쓰기 전용으로 열 때(파일이 없는 경우) : O_WRONLY | O_CREAT | O_TRUNC
    읽기/쓰기/추가용으로 열 때 : O_RDWR | O_APPEND

    mode는 파일의 접근 권한을 설정하는 것이며, O_CREAT를 지정해 파일을 생성할 때만 사용
    open() 함수는 파일 열기에 성공하면 파일 기술자를 리턴한다.

    creat() : 파일 생성
    -----------------------------------------------------------
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    int creat(const char *pathname, mode_t mode);

    * pathname: 파일을 생성할 경로
    * mode: 접근 권한
    -----------------------------------------------------------
    creat() 함수는 파일을 생성하는 전용 함수이며, open()과 다르게 플래그를 지정하는 부분이 없다.

    close() : 파일 닫기
    -----------------------------------------------------------
    #include <unistd.h>

    int close(int fd);

    * fd: 파일 기술자
    -----------------------------------------------------------
    파일 입출력 작업을 모두 완료하면 반드시 파일을 닫아야 하는데 이 때 close() 함수를 사용한다.
    한 프로세스가 열 수 있는 파일 개수에 제한이 있으므로 파일을 제대로 닫지 않으면 최대 허용 개수를 초과해 더 이상 파일을 열지 못할 수 있다.

  ### 파일 읽기와 쓰기

     read(): 파일 읽기
     -----------------------------------------------------------
      #include <unistd.h>

      ssize_t read(int fd, void *buf, size_t count);

      * fd: 파일 기술자
      * buf: 파일에 기록할 데이터를 저장한 메모리 영역
      * count: buf의 크기(기록할 데이터의 크기)
      -----------------------------------------------------------
      read() 함수는 파일 기술자가 가리키는 파일에서 count에 지정한 크기만큼 바이트를 읽어 buf로 지정한 메모리 영역에 저장한다.
      리턴값이 0이면 파일의 끝에 도달해 더 이상 읽을 내용이 없음을 의미함.
      함수를 실행할 때마다 읽은 키만큼 오프셋이 이동해 다음 읽을 위치를 가리킨다.

      write(): 파일 쓰기
      -----------------------------------------------------------
      #include <unistd.h>

      ssize_t write(int fd, const void *buf, size_t count);

      * fd: 파일 기술자
      * buf: 파일에 기록할 데이터를 저장한 메모리 영역
      * count: buf의 크기(기록할 데이터의 크기)
      -----------------------------------------------------------
      파일 기술자는 쓰기 수행할 파일을 가리키고, buf는 파일에 기록할 데이터를 저장하고 있는 메모리 영역을 가리킨다. 
      buf가 가리키는 메모리 영역에서 count로 지정한 크기만큼 읽어 파일에 쓰기를 수행한다.
   
   ### 파일 오프셋 지정

      파일의 내용을 읽거나 쓰면 현재 읽을 위치나 쓸 위치를 알려주는 오프셋이 자동으로 변경된다.
      오프셋은 파일의 시작 지점에서 현재 위치까지의 바이트 수다.

      lseek(): 파일 오프셋 위치 지정
      -----------------------------------------------------------
      #include <sys/types.h>
      #include <unistd.h>

      off_t lseek(int fd, off_t offset, int whence);

      * fd: 파일 기술자
      * offset: 이동할 오프셋 위치
      * whence: 오프셋의 기준 위치
      -----------------------------------------------------------
      lseek() 함수는 파일 기술자가 가리키는 파일에서 offset으로 지정한 크기만큼 오프셋을 이동시킨다.
      offset의 값은 whence의 값을 기준으로 해석한다.

      whence 값
      SEEK_SET
      SEEK_CUR
      SEEK_END

   ### 파일 기술자 복사

      파일을 열면 파일 기술자가 할당 되는데 이를 복사해 같은 파일을 가리키는 두 번째 파일 기술자를 생성할 수 있다.
      입출력 방향 전환에 많이 사용된다.

      dup(): 파일 기술자 복사
      -----------------------------------------------------------
      #include <unistd.h>

      int dup(int oldfd);

      * oldfd: 복사할 파일 기술자
      -----------------------------------------------------------
      dup() 함수는 기존 파일 기술자를 인자로 받아 새로운 파일 기술자를 리턴한다.
      새로 할당되는 파일 기술자는 현재 할당할 수 있는 파일 기술자 중 가장 작은 값으로 자동 할당된다.

      dup2(): 파일 기술자 복사
      -----------------------------------------------------------
      #include <unistd.h>

      int dup2(int oldfd, int newfd);

      * oldfd: 복사할 파일 기술자
      * newfd: 파일 기술자를 복사할 곳
      -----------------------------------------------------------
      dup2() 함수는 새로운 파일 기술자를 지정할 수 있게 해준다.
      파일 기술자 oldfd를 newfd로 복사한다.

   ### 파일 기술자 제어

      현재 열려있는 파일에 대한 파일 기술자의 속성을 확인하고 제어할 수 있다.

      -----------------------------------------------------------
      #include <unistd.h>
      #include <fcntl.h>

      int fcntl(int fd, int cmd, ... /* arg */ );

      * fd: 파일 기술자
      * cmd: 명령
      * arg: cmd에 따라 필요시 지정하는 인자들
      -----------------------------------------------------------
      fcntl() 함수는 파일 기술자가 가리키는 파일에 cmd로 지정한 명령을 수행한다.
      cmd의 종류에 따라 인자를 지정해야 할 수도 있다.
      cmd는 fcntl.h에 정의되어 있다.
      F_GETEL: 상태 플래그 정보를 읽어온다. 
      F_SETFL: 상태 플래그 정보를 설정한다. 

   ### 파일 삭제
   
      파일을 삭제하려면 unlink() 함수를 사용한다. remove()도 같은 기능을 한다.
      remove() 함수는 내부적으로 삭제 대상이 파일이면 unlink() 함수를 호출하고, 삭제 대상이 디렉토리면 rmdir() 함수를 호출.
      즉, 디렉토리가 비어 있을 때만 삭제됨.

      -----------------------------------------------------------
      #include <stdio.h>

      int remove(const char *pathname);
      -----------------------------------------------------------

   ### 파일과 디스크 동기화 함수
      fsync() 함수는 메모리에 위치하고 있는 파일의 내용을 디스크로 보내 메모리와 디스크에 있는 내용을 동기화한다.
      메모리의 내용이 디스크로 모두 기록되기 전에는 리턴하지 않는다.

      -----------------------------------------------------------
      #include <unistd.h>

      int fsync(int fd);

      * fd: 디스크로 저장할 파일의 파일 기술자
      -----------------------------------------------------------
