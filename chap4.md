# chapter 4 파일 입출력

리눅스에서 파일을 읽고 쓰는 방법은 저수준 파일 입출력, 고수준 파일 입출력으로 분류한다.

## 1. 저수준 파일 입출력

   바이트 단위로 입출력을 수행하므로 해당 함수 자체의 구조는 단순하다.

   ### 파일 기술자
   
     현재 열려 있는 파일을 구분할 목적으로 시스템에서 붙여놓은 번호이며, 열린 파일을 참조하는 데 사용하는 지시자 역할을 한다.
     정숫값이며, open() 함수를 사용해 파일을 열 때 부여된다.
     0번: 표준 입력, 1번: 표준 출력, 2번: 표준 오류
     0번은 키보드, 1,2번은 모니터 화면을 의미한다.
     프로세스가 파일을 열 때 파일 기술자에는 0번부터 순서대로 가장 작은 번호가 자동 할당된다.
     물론 처음 동작시 0,1,2번은 자동 할당되기에 3번부터 할당된다.

  ### 파일 생성과 열고 닫기
    파일을 연다는 것은 파일의 내용을 읽거나 파일에 내용을 쓸 수 있는 상태로 변경하는 것을 의미한다.
    작업을 완료하면 파일을 닫아야 한다. 그래야 파일의 내용을 하드 디스크에 온전히 기록하고 파일이 사용한 버퍼 등을 반납할 수 있다.

    open(): 파일 열기
    ---------------------------------------------------------
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    int open(const char *pathname, int flags);
    int open(const char *pathname, int flags, mode_t mode);

    * pathname: 열려는 파일이 있는 경로
    * flags: 파일 상태 플래그
    * mode: 접근 권한
    --------------------------------------------------------
    open() 함수는 pathname에 지정한 파일을 flags에 지정한 상태 플래그의 값에 따라 열고 파일 기술자를 반환한다. 
    파일의 상태를 조정하는 flags 값은 man 명령으로 확인할 수 있다.
    O_RDONLY: 파일을 읽기 전용으로 연다.
    O_WRONLY: 파일을 쓰기 전용으로 연다.
    O_RDWR: 파일을 읽기/쓰기용으로 연다.
    O_CREAT: 파일이 없으면 생성한다. 파일을 생성할 권한은 당연히 있어야 함.
    O_EXCL: O_CREAT와 함께 사용할 경우 기존에 없는 파일이면 파일을 생성하고, 이미 있으면 파일을 생성하지 않고 오류 메시지를 출력
    O_APPEND: 이 옵션을 지정하면 파일의 맨 끝에 내용을 추가한다.
    O_TRUNC: 파일을 생성할 때 이미 있는 파일이고 쓰기 옵션으로 열었으면 내용을 모두 지우고 파일 길이를 0으로 변경한다.
    O_SYNC/O_DSYNC: 파일에 쓰기 동작을 할 때는 보통 버퍼에만 쓰고 나중에 디스크와 같은 저장 장치로 옮겨 쓰는데, 이 옵션이 설정되어 있으면 저장 장치에 쓰기를 마쳐야 쓰기 동작을 완료한다.
                    O_SYNC 플래그는 파일의 수정 시각 속성도 수정할 때까지 기다린다.

    플래그는 OR(|) 연산자로 지정 가능
    쓰기 전용으로 열 때(파일이 있는 경우) : O_WRONLY | O_TRUNC
    쓰기 전용으로 열 때(파일이 없는 경우) : O_WRONLY | O_CREAT | O_TRUNC
    읽기/쓰기/추가용으로 열 때 : O_RDWR | O_APPEND

    mode는 파일의 접근 권한을 설정하는 것이며, O_CREAT를 지정해 파일을 생성할 때만 사용
    open() 함수는 파일 열기에 성공하면 파일 기술자를 리턴한다.

    creat() : 파일 생성
    -----------------------------------------------------------
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>

    int creat(const char *pathname, mode_t mode);

    * pathname: 파일을 생성할 경로
    * mode: 접근 권한
    -----------------------------------------------------------
    creat() 함수는 파일을 생성하는 전용 함수이며, open()과 다르게 플래그를 지정하는 부분이 없다.

    close() : 파일 닫기
    -----------------------------------------------------------
    #include <unistd.h>

    int close(int fd);

    * fd: 파일 기술자
    -----------------------------------------------------------
    파일 입출력 작업을 모두 완료하면 반드시 파일을 닫아야 하는데 이 때 close() 함수를 사용한다.
    한 프로세스가 열 수 있는 파일 개수에 제한이 있으므로 파일을 제대로 닫지 않으면 최대 허용 개수를 초과해 더 이상 파일을 열지 못할 수 있다.

  ### 파일 읽기와 쓰기

     read(): 파일 읽기
     -----------------------------------------------------------
      #include <unistd.h>

      ssize_t read(int fd, void *buf, size_t count);

      * fd: 파일 기술자
      * buf: 파일에 기록할 데이터를 저장한 메모리 영역
      * count: buf의 크기(기록할 데이터의 크기)
      -----------------------------------------------------------
      read() 함수는 파일 기술자가 가리키는 파일에서 count에 지정한 크기만큼 바이트를 읽어 buf로 지정한 메모리 영역에 저장한다.
      리턴값이 0이면 파일의 끝에 도달해 더 이상 읽을 내용이 없음을 의미함.
      함수를 실행할 때마다 읽은 키만큼 오프셋이 이동해 다음 읽을 위치를 가리킨다.

      write(): 파일 쓰기
      -----------------------------------------------------------
      #include <unistd.h>

      ssize_t write(int fd, const void *buf, size_t count);

      * fd: 파일 기술자
      * buf: 파일에 기록할 데이터를 저장한 메모리 영역
      * count: buf의 크기(기록할 데이터의 크기)
      -----------------------------------------------------------
      파일 기술자는 쓰기 수행할 파일을 가리키고, buf는 파일에 기록할 데이터를 저장하고 있는 메모리 영역을 가리킨다. 
      buf가 가리키는 메모리 영역에서 count로 지정한 크기만큼 읽어 파일에 쓰기를 수행한다.
   
   ### 파일 오프셋 지정

      파일의 내용을 읽거나 쓰면 현재 읽을 위치나 쓸 위치를 알려주는 오프셋이 자동으로 변경된다.
      오프셋은 파일의 시작 지점에서 현재 위치까지의 바이트 수다.

      lseek(): 파일 오프셋 위치 지정
      -----------------------------------------------------------
      #include <sys/types.h>
      #include <unistd.h>

      off_t lseek(int fd, off_t offset, int whence);

      * fd: 파일 기술자
      * offset: 이동할 오프셋 위치
      * whence: 오프셋의 기준 위치
      -----------------------------------------------------------
      lseek() 함수는 파일 기술자가 가리키는 파일에서 offset으로 지정한 크기만큼 오프셋을 이동시킨다.
      offset의 값은 whence의 값을 기준으로 해석한다.

      whence 값
      SEEK_SET: 파일의 시작을 기준으로 계산
      SEEK_CUR: 현재 위치를 기준으로 계산
      SEEK_END: 파일의 끝을 기준으로 계산

   ### 파일 기술자 복사

      파일을 열면 파일 기술자가 할당 되는데 이를 복사해 같은 파일을 가리키는 두 번째 파일 기술자를 생성할 수 있다.
      입출력 방향 전환에 많이 사용된다.

      dup(): 파일 기술자 복사
      -----------------------------------------------------------
      #include <unistd.h>

      int dup(int oldfd);

      * oldfd: 복사할 파일 기술자
      -----------------------------------------------------------
      dup() 함수는 기존 파일 기술자를 인자로 받아 새로운 파일 기술자를 리턴한다.
      새로 할당되는 파일 기술자는 현재 할당할 수 있는 파일 기술자 중 가장 작은 값으로 자동 할당된다.

      dup2(): 파일 기술자 복사
      -----------------------------------------------------------
      #include <unistd.h>

      int dup2(int oldfd, int newfd);

      * oldfd: 복사할 파일 기술자
      * newfd: 파일 기술자를 복사할 곳
      -----------------------------------------------------------
      dup2() 함수는 새로운 파일 기술자를 지정할 수 있게 해준다.
      파일 기술자 oldfd를 newfd로 복사한다.

   ### 파일 기술자 제어

      현재 열려있는 파일에 대한 파일 기술자의 속성을 확인하고 제어할 수 있다.

      -----------------------------------------------------------
      #include <unistd.h>
      #include <fcntl.h>

      int fcntl(int fd, int cmd, ... /* arg */ );

      * fd: 파일 기술자
      * cmd: 명령
      * arg: cmd에 따라 필요시 지정하는 인자들
      -----------------------------------------------------------
      fcntl() 함수는 파일 기술자가 가리키는 파일에 cmd로 지정한 명령을 수행한다.
      cmd의 종류에 따라 인자를 지정해야 할 수도 있다.
      cmd는 fcntl.h에 정의되어 있다.
      F_GETEL: 상태 플래그 정보를 읽어온다. 
      F_SETFL: 상태 플래그 정보를 설정한다. 

   ### 파일 삭제
   
      파일을 삭제하려면 unlink() 함수를 사용한다. remove()도 같은 기능을 한다.
      remove() 함수는 내부적으로 삭제 대상이 파일이면 unlink() 함수를 호출하고, 삭제 대상이 디렉토리면 rmdir() 함수를 호출.
      즉, 디렉토리가 비어 있을 때만 삭제됨.

      -----------------------------------------------------------
      #include <stdio.h>

      int remove(const char *pathname);
      -----------------------------------------------------------

   ### 파일과 디스크 동기화 함수
      fsync() 함수는 메모리에 위치하고 있는 파일의 내용을 디스크로 보내 메모리와 디스크에 있는 내용을 동기화한다.
      메모리의 내용이 디스크로 모두 기록되기 전에는 리턴하지 않는다.

      -----------------------------------------------------------
      #include <unistd.h>

      int fsync(int fd);

      * fd: 디스크로 저장할 파일의 파일 기술자
      -----------------------------------------------------------

## 2. 고수준 파일 입출력

   고수준 파일 입출력은 표준 입출력 라이브러리라고도 하며, c언어 표준 함수로 제공됨.

   ### 파일 포인터

      파일 포인터는 디스크에서 메모리로 읽어온 파일의 위치(주소)에 관한 정보를 담고 있는 포인터다.
      시스템 헤더 파일에 정의되어 있는 FILE 포인터(FILE *)형이다.
      플랫폼 독립적인 구조이므로 어느 플랫폼에서든 동일한 동작을 수행한다는 장점이 있다.

   ### 파일 열기와 닫기

      fopen(): 파일 열기
      -----------------------------------------------------------
      #include <stdio.h>

      FILE *fopen(const char *pathname, const char *mode)

      * pathname: 파일의 경로
      * mode: 파일 열기 모드
      -----------------------------------------------------------
      pathname으로 지정한 파일을 mode에서 지정한 모드로 열고 파일 포인터를 리턴한다.

      열기 모드
      r: 읽기 전용으로 텍스트 파일을 연다.
      w: 새로 쓰기용으로 텍스트 파일을 연다. 기존 내용은 삭제됨.
      a: 기존 내용의 끝에 추가해서 쓰기용으로 텍스트 파일을 연다.
      rb: 읽기 전용으로 바이너리 파일을 연다.
      wb: 새로 쓰기용으로 바이너리 파일을 연다. 기존 내용은 삭제됨.
      ab: 추가해서 쓰기용으로 바이너리 파일을 연다.
      r+: 읽기와 쓰기용으로 텍스트 파일을 연다.
      w+: 쓰기와 읽기용으로 텍스트 파일을 연다.
      a+: 추가 쓰기와 읽기용으로 텍스트 파일을 연다.
      rb+: 읽기와 쓰기용으로 바이너리 파일을 연다.
      wb+: 쓰기와 읽기용으로 바이너리 파일을 연다.
      ab+: 추가해서 쓰기와 읽기용으로 바이너리 파일을 연다.

      fclose(): 파일 닫기
      fopen() 함수로 연 파일을 사용한 후에 닫아야 한다.
      -----------------------------------------------------------
      #include <stdio.h>

      int fclose(FILE *stream);

      * stream: fopen()에서 리턴한 파일 포인터
      -----------------------------------------------------------
      fclose() 함수는 fopen() 함수에서 리턴한 파일 포인터를 인자로 지정한 후 메모리에 있는 파일 내용을 디스크에 저장하고 종료한다.

   ### 문자 기반 입출력

      문자 기반 입출력에서는 데이터를 바이트 스트림으로 이해하고 한 바이트씩 처리하는 함수를 제공한다.

      fgetc(), getc(), getchar(), getw(): 문자 기반 입력 함수
      -----------------------------------------------------------
      #include <stdio.h>

      int fgetc(FILE *stream);
      int getc(FILE *stream);
      int getchar(void);
      int getw(FILE *stream);

      * stream: 파일 포인터
      -----------------------------------------------------------
      fgetc(): 파일 포인터가 가리키는 파일로부터 문자 한 개를 unsigned char 형태로 읽어온다.
      getc(): 매크로로 구현되어 있어 실행 속도는 약간 빠르지만 실행 코드가 확장되므로 메모리를 조금 더 차지한다. 
      getchar(): 표준 입력에서 문자 한 개를 읽어오는 매크로
      getw(): 파일에서 워드 단위로 읽어온다. 워드의 크기는 int형의 크기이며 시스템에 따라 달라짐.

      fputc(), putc(), putchar(), putw(): 문자 기반 출력 함수
      -----------------------------------------------------------
      #include <stdio.h>

      int fputc(int c, FILE *stream);
      int putc(int c, FILE *stream);
      int putchar(int c);
      int putw(int w, FILE *stream);

      c, w: 출력할 문자
      stream: 파일 포인터
      -----------------------------------------------------------
      fputc(): 인자로 받은 int형 데이터 c를 unsigned char로 변환해 파일에 쓴다.
      putc(): putc와 같은 동작을 수행, 매크로로 구현됨
      putchar(): 표준 출력으로 한 문자를 출력하는 매크로
      putw(): 워드 단위로 파일에 출력한다.

   ### 문자열 기반 입출력

      gets(), fgets(): 문자열 기반 입력 함수
      -----------------------------------------------------------
      #include <stdio.h>

      char *gets(const char *s);
      char *fgets(char *s, int size, FILE *stream);

      * s: 문자열을 저장한 버퍼의 시작 주소
      * size: 버퍼의 크기
      * stream: 파일 포인터
      -----------------------------------------------------------
      gets(): 표준 입력에서 문자열을 읽어들인다. 읽어들인 문자열의 끝에서 개행 문자(엔터키 값)를 제외하고 널 문자('\0')를 채워 인자 s가 가리키는 영역에 저장하고 리턴
      fgets(): 파일 포인터가 가리키는 파일에서 변수 size에 지정한 길이보다 하나 적게 문자열을 읽어 s에 저장한다. 개행문자를 s에 저장하고, 버퍼의 마지막 문자 다음에 저장

      puts(), fputs(): 문자열 기반 출력 함수
      -----------------------------------------------------------
      #include <stdio.h>

      int puts(const char *s);
      int fputs(const char *s, FILE *stream);

      * s: 문자열 주소
      * stream: 파일 포인터
      -----------------------------------------------------------
      puts(): s가 가리키는 문자열을 표준 출력으로 출력, 개행 문자를 추가해 출력
      fputs(): s가 가리키는 문자열을 파일 포인터가 가리키는 파일로 출력, 출력할때 개행 문자를 출력하지 않는다. 

   ### 버퍼 기반 입출력

      한 번에 입출력하는 버퍼의 크기를 지정해 버퍼 단위로 파일 입출력을 수행하는 방법을 제공

      fread(): 버퍼 기반 입력 함수
      -----------------------------------------------------------
      #include <stdio.h>

      size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);

      * ptr: 버퍼 주소
      * size: 버퍼 크기
      * nmemb: 읽어올 항목 수
      * stream: 파일 포인터
      -----------------------------------------------------------
      fread() 함수는 항목의 크기가 size인 데이터를 nmemb에서 지정한 개수만큼 읽어 ptr이 가리키는 버퍼에 저장

      fwrite(): 버퍼 기반 출력 함수
      -----------------------------------------------------------
      #include <stdio.h>

      size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

      * ptr: 버퍼 주소
      * size: 버퍼 크기
      * nmemb: 읽어올 항목 수
      * stream: 파일 포인터
      -----------------------------------------------------------
      fwrite() 함수는 항목의 크기가 size인 데이터를 nmemb에서 지정한 개수만큼 ptr에서 읽어 stream으로 지정한 파일에 출력
   
   ### 형식 기반 입출력

      정해진 형식이 있는 파일을 읽을 때 유용하게 사용할 수 있다.

      scanf(), fscanf(): 형식 기반 입력 함수
      -----------------------------------------------------------
      #include <stdio.h>

      int scanf(const char *format, ...);
      int fscanf(FILE *stream, const char *format, ...);

      * format: 입력 형식(%d, %s 등)
      * stream: 파일 포인터
      -----------------------------------------------------------
      scanf(): 표준 입력에서 입력을 받음.
      fscanf(): 지정한 파일에서 입력을 받음

      printf(), fprintf(): 형식 기반 출력 함수
      -----------------------------------------------------------
      #include <stdio.h>

      int printf(const char *format, ...);
      int fprintf(FILE *stream, const char *format, ...);

      * stream: 파일 포인터
      * format: 출력 형식
      -----------------------------------------------------------
      printf(): 표준 출력으로 출력
      fprintf(): 지정한 파일로 출력
      출력 대상이 파일이기 때문에 첫번째 인자가 파일 포인터가 된다는 점이 다르다.
   
   ### 파일 오프셋 지정

      fseek(): 파일 오프셋 이동
      -----------------------------------------------------------
      #include <stdio.h>

      int fseek(FILE *stream, long offset, int whence);

      * stream: 파일 포인터
      * offset: 이동할 오프셋
      * whence: 오프셋의 기준 위치
      -----------------------------------------------------------
      stream이 가리키는 파일에서 offset에 지정한 크기만큼 오프셋을 이동시킨다. whence는 offset 값을 해석하는 방법을 결정하는 상수   
      SEEK_SET: 파일의 시작을 기준으로 계산 
      SEEK_CUR: 현재 위치를 기준으로 계산
      SEEK_END: 파일의 끝을 기준으로 계산

      ftell(): 현재 오프셋 구하기
      -----------------------------------------------------------
      #include <stdio.h>

      long ftell(FILE *stream);

      * stream: 파일 포인터
      -----------------------------------------------------------
      인자로 지정한 파일의 현재 오프셋을 리턴한다. 리턴하는 오프셋은 파일의 시작에서 현재 오프셋 위치까지의 바이트 수다.

      rewind(): 처음 위치로 오프셋 이동
      -----------------------------------------------------------
      #include <stdio.h>

      void rewind(FILE *stream);

      * stream: 파일 포인터
      -----------------------------------------------------------
      오프셋 위치를 파일의 시작으로 즉시 이동시킨다.

   ### 파일과 디스크 동기화 함수

      고수준 파일 입출력 함수는 기본적으로 버퍼의 내용을 디스크로 옮겨 쓰는데, 항상 보장되지 않으므로 강제로 수행시킨다.

      -----------------------------------------------------------
      #include <stdio.h>

      int fflush(FILE *stream);

      *stream: 파일 포인터
      -----------------------------------------------------------
      버퍼에 있는 데이터를 파일에 기록한다. 파일을 읽기 전용으로 연 경우 버퍼에 있는 내용을 모두 비운다.

## 파일 기술자와 파일 포인터 변환

      파일 기술자와 파일 포인터는 상호 변환할 수 있다.
      파일 기술자에서 파일 포인터를 생성하려면 fdopen(), 파일 포인터에서 파일 기술자 정보를 추출하려면 fileno()를 사용한다.

      fdopen(): 파일 포인터 생성
      -----------------------------------------------------------
      #include <stdio.h>

      FILE *fdopen(int fd, const char *mode);

      * fd: 파일 기술자
      * mode: 열기 모드
      -----------------------------------------------------------
      파일 기술자와 모드를 인자로 받아 파일 포인터를 생성한다. 두번째 인자인 mode에 사용할 수 있는 값은 fopen()에서 사용한 값.
      mode에 값을 지정할 때는 파일 기술자를 열 때와 같은 종류의 값으로 지정해야 한다.

      fileno(): 파일 기술자 생성
      -----------------------------------------------------------
      #include <stdio.h>

      int fileno(FILE *stream);

      * stream: 파일 포인터
      -----------------------------------------------------------
      파일 포인터를 인자로 받아 파일 기술자를 리턴함.

## 임시 파일 사용

   같은 프로그램을 여러 사용자가 동시에 사용하는 경우 임시 파일명이 동일하면 문제가 발생하기 때문에 중복되지 않도록 생성되게 해야 함.

   ### 임시 파일명 생성

      tmpnam(): 임시 파일명 생성
      -----------------------------------------------------------
      #include <stdio.h>

      char *tmpnam(char *s);

      * s: 파일명을 저장할 버퍼의 시작 주소
      -----------------------------------------------------------
      임시 파일명을 시스템이 알아서 지정. 
      인자가 있는 경우 해당 인자가 가리키는 곳에 임시 파일명을 저장하고, 인자가 NULL이면 임시 파일명을 리턴한다.

      mktemp(): 템플릿을 지정한 임시 파일명 생성
      -----------------------------------------------------------
      #include <stdlib.h>

      char *mktemp(char *template);

      * template: 임시 파일명의 템플릿
      -----------------------------------------------------------
      임시 파일의 템플릿을 인자로 받아 이를 임시 파일명으로 변환해 리턴한다. 인자로 지정하는 템플릿은 대문자 X 6개로 마쳐야 한다.
      이 함수는 대문자 X 부분을 다른 문자로 대체해 임시 파일명을 만든다.

   ### 임시 파일의 파일 포인터와 파일 기술자 생성

      위 함수들은 임시 파일의 이름만 생성하기 때문에 해당 임시 파일을 대상으로 입출력을 수행하려면 파일을 열어야 한다.
      임시 파일명은 알 필요없고 임시 파일에 대한 파일 포인터만 필요하면 tmpfile() 함수 사용, 파일 기술자가 필요하면 mkstemp() 함수 사용
      tmpfile(): 자동으로 w+ 모드로 열린 파일 포인터를 리턴한다.
      mkstemp(): 템플릿으로 임시 파일명을 지정해 열고 파일 기술자를 리턴한다.
      -----------------------------------------------------------
      #include <stdio.h>

      FILE *tmpfile();

      #include <stdlib.h>

      int mkstemp(char *template);

      * template: 임시 파일명의 템플릿
      -----------------------------------------------------------
